{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MEGAnno documentation","text":""},{"location":"#what-is-meganno","title":"What is MEGAnno?","text":"<p>MEGAnno is a human-LLM collaborative annotation framework. For cost-efficient and high-quality annotation, we adopt the LLM annotation --&gt; Human verification workflow where LLM agents label data first and then humans verify a subset of potentially problematic LLM labels.  Figure 1. Our human-LLM collaborative workflow.</p> <p>Our features include:</p> <ul> <li>Effective LLM agent and annotation management</li> <li>Convenient and robust LLM annotation</li> <li>Exploration and verification of LLM labels by humans</li> <li>Seamless annotation experience within Jupyter notebooks</li> </ul>"},{"location":"#system-overview","title":"System Overview","text":"<p>MEGAnno provides two key components: (1) a Python client library featuring interactive widgets and (2) a back-end service consisting of web API and database servers. To use our system, a user can interact with a Jupyter Notebook that has the MEGAnno client installed. Through programmatic interfaces and UI widgets, the client communicates with the service.  Figure 2. Overview of MEGAnno+ system.</p>"},{"location":"#demo","title":"Demo","text":"<p>For Megagon hosted demo, please head to https://meganno.github.io/.</p> <p> Table view of the annotation widget. Data examples are organized in a table for better exploration and comparison. Users can also search over, sort or filter on data and annotations.</p> <p> Single view of the annotation widget showing one data example at a time. With more space, the single view is more suitable for span-level tasks like extraction.</p> <p>Please see the Getting Started page for setup instructions and the Advanced Features page for more cool features we provide.</p>"},{"location":"advanced/","title":"Advanced features","text":"<p>This notebook provides examples of some of the advanced features.</p>"},{"location":"advanced/#updating-schema","title":"Updating Schema","text":"<p>Annotation requirements can change as projects evolve. To update the schema for a project, simply call <code>set_schemas</code> with the new schema object. For example, to expand the schema we set in the basic notebook: <pre><code>demo.get_schemas().set_schemas({\n    'label_schema': [\n        {\n            \"name\": \"sentiment\",\n            \"level\": \"record\", \n            \"options\": [\n                { \"value\": \"pos\", \"text\": \"positive\" },\n                { \"value\": \"neg\", \"text\": \"negative\" },\n                { \"value\": \"neu\", \"text\": \"neutral\" } # adding a new option\n            ]\n        },\n        # adding a span-level label\n                {\n            \"name\": \"sp\",\n            \"level\": \"span\", \n            \"options\": [\n                { \"value\": \"pos\", \"text\": \"positive\" },\n                { \"value\": \"neg\", \"text\": \"negative\" },\n            ]\n        }\n    ]\n})\n</code></pre> Only the latest schema will be active, but all previous ones will be preserved. To see the full history: <pre><code>demo.get_schemas().get_history()\n</code></pre></p>"},{"location":"advanced/#metadata","title":"Metadata","text":"<p>In Labeler, metadata refers to auxiliary information associated with data records. Labeler takes user-defined functions to generate metadata and uses it to find important subsets and assist human annotators. Here we show two examples.</p> <p>Example 1: Adding sentence bert embeddings for data records. The embeddings can later be used to make similarity computations over records. <pre><code># Example 1, adding sentence-bert embedding.\nfrom sentence_transformers import SentenceTransformer\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n# set metadata generation function \ndemo.set_metadata(\"bert-embedding\",lambda x: list(model.encode(x).astype(float)), 500)\n</code></pre></p> <p>Example 2: Extracting hashtags as annotation context. <pre><code># user defined function to extract hashtag\ndef extract_hashtags(text):\n    hashtag_list = []\n    for word in text.split():\n        if word[0] == '#':\n            hashtag_list.append(word[:])\n    # widget can render markdown text\n    return ''.join(['- {}\\n'.format(x) for x in hashtag_list])\n\n# apply metadata to the project\ndemo.set_metadata(\"hashtag\", lambda x: extract_hashtags(x), 500)\n</code></pre></p> <p>With <code>hashtag</code> metadata, Labeler widget can show it as context at annotation time.</p> <p><pre><code>s1= demo.search(keyword='',\n              limit=50,\n              skip=0,\n              meta_names=['hashtag'])\ns1.show()\n</code></pre> </p>"},{"location":"advanced/#advanced-subset-generation","title":"Advanced Subset Generation","text":"<p>In addition to exact keyword matches, Labeler also provides more advanced approaches of generating subsets.</p>"},{"location":"advanced/#regex-based-searches","title":"Regex-based searches","text":"<p>Labeler supports searches based on regular expressions: <pre><code>s2_reg= demo.search(regex='*#delay*',\n                  limit=50,\n                  skip=0)\ns2_reg.show({'view':'table'})\n</code></pre></p>"},{"location":"advanced/#subset-suggestion","title":"Subset Suggestion","text":"<p>Searches initiated by users can help them explore the dataset in a controlled way. Still, the quality of searches is only as good as users\u2019 knowledge about the data and domain. Labeler provides an automated subset suggestion engine to assist with exploration. Embedding-based suggestions make suggestions based on data-embedding vectors provided by the user (as metadata). </p> <p>For example, suggest_similar suggests neighbors (based on distance in the embedding space) of data in the querying subset:</p> <pre><code>s3 = demo.search(keyword='delay', limit=3, skip=0) # source subset\ns4 = s3.suggest_similar('bert-embedding', limit=4) # needs to provide a valid meta_name\ns4.show()\n</code></pre>"},{"location":"advanced/#subset-computation","title":"Subset Computation","text":"<p>Labeler support set operations to build more subsets from others: <pre><code># intersection\ns_intersection = s1 &amp; s2 # or s1.intersection(s2)\n# union\ns_union = s1 | s2 # or s1.union(s2)\n# difference\ns_diff = s1 - s2 # or s1.difference(s2)\n</code></pre></p>"},{"location":"advanced/#dashboard","title":"Dashboard","text":"<p>Labeler provides a built-in visual monitoring dashboard to help users to get real-time status of the annotation project. As projects evolve, users would often need to understand the project\u2019s status to make decisions about the next steps, like collecting more data points with certain characteristics or adding a new class to the task definition. To aid such analysis, the dashboard widget packs common statistics and analytical visualizations (e.g., annotation progress, distribution of labels, annotator agreement, etc.) based on a survey of our pilot users.</p> <p></p> <p>To bring up the project dashboard: <pre><code>demo.show()\n</code></pre></p> <p>Other features</p> <ul> <li>Assignment and dispatch</li> <li>Multiple annotators and reconciliation</li> </ul>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#key-concepts","title":"Key concepts","text":"<p>To fill</p> <ul> <li>Record</li> <li>Schema</li> <li>Subset </li> <li>Metadata</li> <li>Assignment </li> </ul>"},{"location":"overview/#developers-guide","title":"Developer's guide","text":""},{"location":"overview/#mkdocs-usage","title":"mkdocs usage","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"overview/#document-layout","title":"document layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"quickstart/","title":"Getting Started","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<ol> <li>Download conda</li> <li>Create a conda environment<ul> <li>Run <code>conda create -n &lt;env_name&gt; python=3.9</code></li> <li>Run <code>conda activate &lt;env_name&gt;</code></li> </ul> </li> <li> <p>Install meganno-client with meganno-ui (recommended for notebook users)</p> <p>You can use either <code>SSH</code> or <code>HTTPS</code> to install this python package.</p> <p>Add @vx.x.x tag after the github URL</p> <ul> <li>Run <code>pip install \"meganno_client[ui] @ git+ssh://git@github.com/megagonlabs/meganno-client.git\"</code></li> <li>Run <code>pip install \"meganno_client[ui] @ git+https://github.com/megagonlabs/meganno-client.git\"</code><ul> <li>You may need to use personal access token instead of password</li> </ul> </li> </ul> <p>To install without meganno-ui</p> <ul> <li>Run <code>pip install git+ssh://git@github.com/megagonlabs/meganno-client.git</code></li> <li>Run <code>pip install git+https://github.com/megagonlabs/meganno-client.git</code><ul> <li>You may need to use personal access token instead of password</li> </ul> </li> </ul> </li> <li> <p>Set up OpenAI API Keys using environment variables in place of your API key </p> </li> </ol>"},{"location":"quickstart/#self-hosted-service","title":"Self-hosted service","text":"<ul> <li>Download docker compose files at meganno-service</li> <li>Follow setup instructions</li> </ul>"},{"location":"quickstart/#authentication","title":"Authentication","text":"<p>We have 2 ways to authenticate with the service:</p> <ol> <li>Short-term 1 hour access with username and password sign in.<ul> <li>require re-authentication every hour.</li> </ul> </li> <li>Long-term access with access token without signing in every time.</li> </ol>"},{"location":"quickstart/#basic-usages","title":"Basic Usages","text":"<p>Please also refer to this notebook for a running example of the basic pipeline of using labeler in a notebook.</p>"},{"location":"quickstart/#setting-schema","title":"Setting Schema","text":"<p>Schema defines the annotation task. Example of setting schema for a sentiment analysis task with positive and negative options.  <pre><code>demo.get_schemas().set_schemas({\n    'label_schema': [\n        {\n            \"name\": \"sentiment\",\n            \"level\": \"record\", \n            \"options\": [\n                { \"value\": \"pos\", \"text\": \"positive\" },\n                { \"value\": \"neg\", \"text\": \"negative\" },\n            ]\n        }\n    ]\n})\ndemo.get_schemas().value(active=True)       \n</code></pre> A label can be defined to have level <code>record</code> or <code>span</code>. Record-level labels correspond to the entire data record, while span-level labels are associated with a text span in the record. See Updating Schema for an example of a more complex schema.</p>"},{"location":"quickstart/#importing-data","title":"Importing Data","text":"<p>Given a pandas dataframe like this (example generated from this Twitter US Airline Sentiment dataset):</p> id tweet 0 @united how else would I know it was denied? 1 @JetBlue my SIL bought tix for us to NYC. We were told at the gate that her cc was declined. Supervisor accused us of illegal activity. 2 @JetBlue dispatcher keeps yelling and hung up on me! <p>Importing data is easy by providing column names for <code>id</code> which is a unique importing identifier for data records, and <code>content</code> which is the raw text field.</p> <pre><code>demo.import_data_df(df, column_mapping={\n    'id':'id',\n    'content':'tweet'\n})\n</code></pre>"},{"location":"quickstart/#exploratory-labeling","title":"Exploratory Labeling","text":"<p>Not all data points are equally important for downstream models and applications. There are often cases where users might want to prioritize a particular batch (e.g., to achieve better class or domain coverage or focus on the data points that the downstream model cannot predict well). Labeler provides a flexible and controllable way of organizing annotation projects through the exploratory labeling. This annotation process is done by first identifying an interesting subset and assigning labels to data in the subset. We provide a set of \u201cpower tools\u201d to help identify valuable subsets.</p> <p>The script below shows an example of searching for data records with keyword \"delay\" and bringing up a widget for annotation in the next cell. More examples here. <pre><code># search results =&gt; subset s1\ns1 = demo.search(keyword='delay', limit=10, skip=0)\n# bring up a widget \ns1.show()\n</code></pre></p>"},{"location":"quickstart/#column-filters","title":"Column Filters","text":"<p> To view all column filters, click on \"Filters\" button; to reset all column filters, click on \"Reset filters\" button.</p>"},{"location":"quickstart/#column-order-visibility","title":"Column Order &amp; Visibility","text":"<p> 1. To re-order and re-size column, mouse over column drag handler (left grip handler for re-order and right column edge for re-size). 2. To toggle column visiblity, click on \"Columns\", then toggle column to show/hide. 3. To reset column ordering and visibility, click on \"Reset columns\" button. </p>"},{"location":"quickstart/#editing-modes","title":"Editing Modes","text":"<p> To toggle editing mode, click on the mode button, then toggle bewteen Annotating or Reconciling mode.</p>"},{"location":"quickstart/#metadata-focus-view","title":"Metadata Focus-view","text":"<p> To focus on a single metadata value, click on \"Settings\" button, then choose a metadata name from the list.</p>"},{"location":"quickstart/#exporting","title":"Exporting","text":"<p>Although iterations can happen within a single notebook, it's easy to export the data, and annotations collected:</p> <pre><code># collecting the annotation generated by all annotators\ndemo.export()\n</code></pre>"},{"location":"references/schema/","title":"Schema","text":""},{"location":"references/schema/#labeler_client.schema.Schema","title":"<code>labeler_client.schema.Schema</code>","text":"<p>The Schema class is used to define the schema for labeling annotations.</p> <p>Attributes:</p> Name Type Description <code>__service</code> <code>object</code> <p>Service object for the connected project.</p>"},{"location":"references/schema/#labeler_client.schema.Schema.set_schemas","title":"<code>set_schemas(schemas=None)</code>","text":"<p>Sets the user-defined schema</p> <p>Parameters:</p> Name Type Description Default <code>schemas</code> <code>dict</code> <p>Schema of annotation task which defines a <code>label_schema</code> which is a list of Python dictionaries defining the <code>name</code> of the label, the <code>level</code> of the label and <code>options</code> which defines a list of valid label options</p> <p>Full Example: <pre><code>{\n    \"label_schema\": [\n        {\n            \"name\": \"sentiment\",\n            \"level\": \"record\",\n            \"options\": [\n                {\n                    \"value\": \"pos\",\n                    \"text\": \"positive\"\n                },\n                {\n                    \"value\": \"neg\",\n                    \"text\": \"negative\"\n                }\n            ]\n        },\n\n    ]\n}\n</code></pre></p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If response code is not successful</p> <p>Returns:</p> Name Type Description <code>response</code> <code>json</code> <p>A json of the response</p>"},{"location":"references/schema/#labeler_client.schema.Schema.value","title":"<code>value(active=None)</code>","text":"<p>Get project schema</p> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>bool</code> <p>If <code>True</code>, only retrieve the active(latest) schema; if <code>False</code>, retrieve all previous schema; if <code>None</code>, retrieve  full history.</p> <code>None</code>"},{"location":"references/schema/#labeler_client.schema.Schema.get_active_schemas","title":"<code>get_active_schemas()</code>","text":"<p>Get the active schema for the project.</p>"},{"location":"references/schema/#labeler_client.schema.Schema.get_history","title":"<code>get_history()</code>","text":"<p>Get the full history of project schema</p>"},{"location":"references/service/","title":"Service","text":""},{"location":"references/service/#labeler_client.service.Service","title":"<code>labeler_client.service.Service</code>","text":"<p>Service objects communicate to back-end Labeler services and establish connections to a Labeler project.</p>"},{"location":"references/service/#labeler_client.service.Service.__init__","title":"<code>__init__(host=None, project=None, token=None, auth=None, port=5000)</code>","text":"<p>Init function</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host IP address for the back-end service to connect to. If None, connects to Megagon-hosted service.</p> <code>None</code> <code>project</code> <code>str</code> <p>Project name. The name needs to be unique within the host domain.</p> <code>None</code> <code>token</code> <code>str</code> <p>User's authentication token.</p> <code>None</code> <code>auth</code> <code>Authentication</code> <p>Authentication object. Can be skipped if valid token is provided.</p> <code>None</code>"},{"location":"references/service/#labeler_client.service.Service.show","title":"<code>show(config={})</code>","text":"<p>Show project management dashboard in a floating dashboard.</p>"},{"location":"references/service/#labeler_client.service.Service.get_service_endpoint","title":"<code>get_service_endpoint(key=None)</code>","text":"<p>Get REST endpoint for the connected project. Endpoints are composed from base project url and routes for specific requests.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the specific request. Mapping to routes is stored in a dictionary <code>SERVICE_ENDPOINTS</code> in <code>constants.py</code>.</p> <code>None</code>"},{"location":"references/service/#labeler_client.service.Service.get_base_payload","title":"<code>get_base_payload()</code>","text":"<p>Get the base payload for any REST request which includes the authentication token.</p>"},{"location":"references/service/#labeler_client.service.Service.get_schemas","title":"<code>get_schemas()</code>","text":"<p>Get schema object for the connected project.</p>"},{"location":"references/service/#labeler_client.service.Service.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get the statistics object for the project which supports calculations in the management dashboard.</p>"},{"location":"references/service/#labeler_client.service.Service.get_users_by_uids","title":"<code>get_users_by_uids(uids: list = [])</code>","text":"<p>Get user names by their unique IDs.</p> <p>Parameters:</p> Name Type Description Default <code>uids</code> <code>list</code> <p>list of unique user IDs.</p> <code>[]</code>"},{"location":"references/service/#labeler_client.service.Service.get_annotator","title":"<code>get_annotator()</code>","text":"<p>Get annotator's own name and user ID. The back-end service distinguishes annotator by the token or auth object used to initialize the connection.</p>"},{"location":"references/service/#labeler_client.service.Service.search","title":"<code>search(limit=DEFAULT_LIST_LIMIT, skip=0, uuid_list=None, keyword=None, regex=None, record_metadata_condition=None, annotator_list=None, label_condition=None, label_metadata_condition=None, verification_condition=None)</code>","text":"<p>Search the back-end database based on user-provided predicates.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <p>The limit of returned records in the subest.</p> <code>DEFAULT_LIST_LIMIT</code> <code>skip</code> <p>skip index of returned subset (excluding the first <code>skip</code> rows from the raw results ordered by importing order).</p> <code>0</code> <code>uuid_list</code> <p>list of record uuids to filter on</p> <code>None</code> <code>keyword</code> <p>Term for exact keyword searches.</p> <code>None</code> <code>regex</code> <p>Term for regular expression searches.</p> <code>None</code> <code>record_metadata_condition</code> <p>{\"name\": # name of the record-level metadata to filter on \"opeartor\": \"==\"|\"&lt;\"|\"&gt;\"|\"&lt;=\"|\"&gt;=\"|\"exists\", \"value\": # value to complete the expression}</p> <code>None</code> <code>annotator_list</code> <p>list of annotator names to filter on</p> <code>None</code> <code>label_condition</code> <p>Label condition of the annotation. {\"name\": # name of the label to filter on \"opeartor\": \"==\"|\"&lt;\"|\"&gt;\"|\"&lt;=\"|\"&gt;=\"|\"exists\"|\"conflicts\", \"value\": # value to complete the expression}</p> <code>None</code> <code>label_metadata_condition</code> <p>Label metadata condition of the annotation. Note this can be on different labels than label_condition {\"label_name\": # name of the associated label \"name\": # name of the label-level metadata to filter on \"operator\": \"==\"|\"&lt;\"|\"&gt;\"|\"&lt;=\"|\"&gt;=\"|\"exists\", \"value\": # value to complete the expression}</p> <code>None</code> <code>verification_condition</code> <p>verification condition of the annotation. {\"label_name\": # name of the associated label  \"search_mode\":\"ALL\"|\"UNVERIFIED\"|\"VERIFIED\"}</p> <code>None</code> <p>Returns:</p> Name Type Description <code>subset</code> <code>Subset</code> <p>Subset meeting the search conditions.</p>"},{"location":"references/service/#labeler_client.service.Service.deprecate_submit_annotations","title":"<code>deprecate_submit_annotations(subset=None, uuid_list=[])</code>","text":"<p>Submit annotations for records in a subset to the back-end service database. Results are filtered to only include annotations owned by the authenticated annotator.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Subset</code> <p>The subset object containing records and annotations.</p> <code>None</code> <code>uuid_list</code> <code>list</code> <p>Additional filter. Only subset records whose uuid are in this list will be submitted.</p> <code>[]</code>"},{"location":"references/service/#labeler_client.service.Service.submit_annotations","title":"<code>submit_annotations(subset=None, uuid_list=[])</code>","text":"<p>Submit annotations for a batch of records in a subset to the back-end service database. Results are filtered to only include annotations owned by the authenticated annotator.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Subset</code> <p>The subset object containing records and annotations.</p> <code>None</code> <code>uuid_list</code> <code>list</code> <p>Additional filter. Only subset records whose uuid are in this list will be submitted.</p> <code>[]</code>"},{"location":"references/service/#labeler_client.service.Service.import_data_url","title":"<code>import_data_url(url='', file_type=None, column_mapping={})</code>","text":"<p>Import data from a public url, currently only supporting csv files. Each row corresponds to a data record. The file needs at least two columns: one with a unique id for each row, and one with the raw data content.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Public url for csv file</p> <code>''</code> <code>file_type</code> <code>str</code> <p>Currently only supporting type 'CSV'</p> <code>None</code> <code>column_mapping</code> <code>dict</code> <p>Dictionary with fields <code>id</code> specifying id column name, and <code>content</code> specifying content column name. For example, with a csv file with two columns <code>index</code> and <code>tweet</code>: <pre><code>{\n    \"id\": \"index\",\n    \"content\": \"tweet\"\n}\n</code></pre></p> <code>{}</code>"},{"location":"references/service/#labeler_client.service.Service.import_data_df","title":"<code>import_data_df(df, column_mapping={})</code>","text":"<p>Import data from a pandas DataFrame. Each row corresponds to a data record. The dataframe needs at least two columns: one with a unique id for each row, and one with the raw data content.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Qualifying dataframe</p> required <code>column_mapping</code> <code>dict</code> <p>Dictionary with fields <code>id</code> specifying id column name, and <code>content</code> specifying content column name. Using a dataframe, users can import metadata at the same time. For example, with a csv file with two columns <code>index</code> and <code>tweet</code>, and a column <code>location</code>: <pre><code>{\n    \"id\": \"index\",\n    \"content\": \"tweet\",\n    \"metadata\": \"location\"\n}\n</code></pre> metadata with name <code>location</code> will be created for all imported data records.</p> <code>{}</code>"},{"location":"references/service/#labeler_client.service.Service.export","title":"<code>export()</code>","text":"<p>Exporting function.</p> <p>Returns:</p> Name Type Description <code>export_df</code> <code>DataFrame</code> <p>A pandas dataframe with columns <code>'data_id', 'content', 'annotator', 'label_name', 'label_value'</code> for all records in the project</p>"},{"location":"references/service/#labeler_client.service.Service.set_metadata","title":"<code>set_metadata(meta_name, func, batch_size=500)</code>","text":"<p>Set metadata for all records in the back-end database, based on user-defined function for metadata calculation.</p> <p>Parameters:</p> Name Type Description Default <code>meta_name</code> <code>str</code> <p>Name of the metadata. Will be used to identify and query the metadata.</p> required <code>func</code> <code>function(raw_content)</code> <p>Function which takes input the raw data content and returns the corresponding metadata (int, string, vectors...).</p> required <code>batch_size</code> <code>int</code> <p>Batch size for back-end database updates.</p> <code>500</code> Example <pre><code>from sentence_transformers import SentenceTransformer\n\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n# set metadata generation function for service object demo\ndemo.set_metadata(\"bert-embedding\",\n                  lambda x: list(model.encode(x).astype(float)), 500)\n</code></pre>"},{"location":"references/service/#labeler_client.service.Service.get_assignment","title":"<code>get_assignment(annotator=None, latest_only=False)</code>","text":"<p>Get workload assignment for annotator.</p> <p>Parameters:</p> Name Type Description Default <code>annotator</code> <code>str</code> <p>User ID to query. If set to None, use ID of auth token holder.</p> <code>None</code> <code>latest_only</code> <code>bool</code> <p>If true, return only the last assignment for the user. Else, return the set of all assigned records.</p> <code>False</code>"},{"location":"references/statistic/","title":"Statistic","text":""},{"location":"references/statistic/#labeler_client.statistic.Statistic","title":"<code>labeler_client.statistic.Statistic</code>","text":"<p>The Statistic class defines methods which show basic statistics of the labeling project. Mostly used to back views in the monitoring dashboard.</p> <p>Attributes:</p> Name Type Description <code>__service</code> <code>Service</code> <p>Service object for the connected project.</p>"},{"location":"references/statistic/#labeler_client.statistic.Statistic.get_label_progress","title":"<code>get_label_progress()</code>","text":"<p>Get the overall label progress.</p> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A dictionary with fields <code>total</code> showing total number for data records, and <code>annotated</code> showing number of records with any label from at least one annotator.</p>"},{"location":"references/statistic/#labeler_client.statistic.Statistic.get_label_distributions","title":"<code>get_label_distributions(label_name: str = None)</code>","text":"<p>Gets class distributions for specified label. If multiple annotators labeled the same record, aggregate using <code>majority vote</code>.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>Name of label as specified in the schema.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A dictionary showing aggregated class frequencies. Example: <code>{'neg': 60, 'neu': 14, 'pos': 27, 'tied_annotations': 3}</code>. <code>tied_annotation</code> counts numbers of record when there's more than majority voted classes.</p>"},{"location":"references/statistic/#labeler_client.statistic.Statistic.get_annotator_contributions","title":"<code>get_annotator_contributions()</code>","text":"<p>Get contributions of annotators in terms of records labeled.</p> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A dictionary where keys are annotator IDs and values are total numbers of annotated records by each annotator.</p>"},{"location":"references/statistic/#labeler_client.statistic.Statistic.get_annotator_agreements","title":"<code>get_annotator_agreements(label_name: str = None)</code>","text":"<p>Gets pairwise agreement score between all contributing annotators to the project, on the specified label. The default agreement calculation method is <code>cohen_kappa</code>.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>Name of label as specified in the schema.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A dictionary where keys are pairs of annotator IDs, and values are their agreement scores. The higher the scores are, the more frequent the pairs of annotators agree.</p>"},{"location":"references/statistic/#labeler_client.statistic.Statistic.get_embeddings","title":"<code>get_embeddings(label_name: str = None, embed_type: str = None)</code>","text":"<p>Returns 2-dimensional TSNE projection of the text embedding for data records, together with their aggregated labels (using majority votes). Used for projection view in the monitoring dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>Name of label as specified in the schema.</p> <code>None</code> <code>embed_type</code> <code>str</code> <p>the meta_name for the specified embedding</p> <code>None</code> <p>Returns:</p> Name Type Description <code>response</code> <code>dict</code> <p>A dictionary with fields <code>agg_label</code> showing aggregated class label, <code>x_axis</code> and <code>y_axis</code> showing projected 2d coordinates.</p>"},{"location":"references/subset/","title":"Subset","text":""},{"location":"references/subset/#labeler_client.subset.Subset","title":"<code>labeler_client.subset.Subset</code>","text":"<p>The Subset class is used to represent a group of data records</p> <p>Attributes:</p> Name Type Description <code>__data_uuids</code> <code>list</code> <p>List of unique identifiers of data records in the subset.</p> <code>__service</code> <code>Service</code> <p>Connected backend service</p> <code>__my_annotation_list</code> <code>list</code> <p>Local cache of the record and annotation view of the subset owned by service.annotator_id. with all possible metadata.</p>"},{"location":"references/subset/#labeler_client.subset.Subset.__init__","title":"<code>__init__(service, data_uuids=[], job_id=None)</code>","text":"<p>Init function</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>Service</code> <p>Service-class object identifying the connected backend service and corresponding data storage</p> required <code>data_uuids</code> <code>list</code> <p>List of data uuid's to be included in the subset</p> <code>[]</code>"},{"location":"references/subset/#labeler_client.subset.Subset.get_uuid_list","title":"<code>get_uuid_list()</code>","text":"<p>Get list of unique identifiers for all records in the subset.</p> <p>Returns:</p> Name Type Description <code>__data_uuids</code> <code>list</code> <p>List of data uuids included in Subset</p>"},{"location":"references/subset/#labeler_client.subset.Subset.value","title":"<code>value(annotator_list: list = None)</code>","text":"<p>Check for cached data and annotations of service owner, or retrieve for other annotators (not cached).</p> <p>Parameters:</p> Name Type Description Default <code>annotator_list</code> <code>list</code> <p>if None, retrieve cached own annotator. else, fetch live annotation from others.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>subset_annotation_list</code> <code>list</code> <p>See <code>__get_annotation_list</code> for description and example.</p>"},{"location":"references/subset/#labeler_client.subset.Subset.get_annotation_by_uuid","title":"<code>get_annotation_by_uuid(uuid)</code>","text":"<p>Returns the annotation for a particular data record (specified by uuid)</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>the uuid for the data record specified by user</p> required <p>Returns:</p> Name Type Description <code>annotation</code> <code>dict</code> <p>Annotation for specified data record if it exists else None</p>"},{"location":"references/subset/#labeler_client.subset.Subset.show","title":"<code>show(config={})</code>","text":"<p>Visualize the current subset in an in-notebook annotation widget.</p> <p>Development note: initializing an Annotation widget, creating unique reference to the associated subset and service.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Configuration for default view of the widget.</p> <pre><code>- view : \"single\" | \"table\", default \"single\"\n- mode : \"annotating\" | \"reconciling\", default \"annotating\"\n- title: default \"Annotation\"\n- height: default 300 (pixels)\n</code></pre> <code>{}</code>"},{"location":"references/subset/#labeler_client.subset.Subset.set_annotations","title":"<code>set_annotations(uuid=None, labels=None)</code>","text":"<p>Sets the annotation for a particular data record with the specified label</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>the uuid for the data record specified by user</p> <code>None</code> <code>labels</code> <code>dict</code> <p>The labels for the data record at record and span level, with the following structure:</p> <pre><code>- \"labels_record\" : list\n    A list of record-level labels\n- \"labels_span\" : list\n    A list of span-level labels\n\nExamples\n-------\n\nExample of setting an annotation with the desired record and span level labels:\n```json\n{\n    \"labels_record\": [\n        {\n            \"label_name\": \"sentiment\",\n            \"label_value\": [\"neu\"]\n        }\n    ],\n\n    \"labels_span\": [\n        {\n            \"label_name\": \"sentiment\",\n            \"label_value\": [\"neu\"],\n            \"start_idx\": 10,\n            \"end_idx\": 20\n        }\n    ]\n}\n```\n</code></pre> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If uuid or labels is None</p> <p>Returns:</p> Name Type Description <code>labels</code> <code>dict</code> <p>Updated labels for uuid annotated by user</p>"},{"location":"references/subset/#labeler_client.subset.Subset.get_reconciliation_data","title":"<code>get_reconciliation_data(uuid_list=None)</code>","text":"<p>Returns the list of reconciliation data for all data entries specified by user. The reconciliation data for one data record consists of the annotations for it by all annotators</p> <p>Parameters:</p> Name Type Description Default <code>uuid_list</code> <code>list</code> <p>list of uuid's provided by user. If None, use all records in the subset</p> <code>None</code> <p>Returns:</p> Name Type Description <code>reconciliation_data_list</code> <code>list</code> <p>List of reconciliation data for each uuid with the following keys: <code>annotation_list</code> which specifies all the annotations for the uuid, <code>data</code> which contains the raw data specified by the uuid, <code>metadata</code> which stores additional information about the data, <code>tokens</code> , and the <code>uuid</code> of the data record Full Example: <pre><code>{\n    \"annotation_list\": [\n        {\n            \"annotator\": \"pwOA1N9RKZVJM8VZZ7w8VcT8lp22\",\n            \"labels_record\": [],\n            \"labels_span\": []\n        },\n        {\n            \"annotator\": \"IAzgHOxyeLQBi5QVo7dQR0p2DpA2\",\n            \"labels_record\": [\n                {\n                    \"label_name\": \"sentiment\",\n                    \"label_value\": [\"pos\"]\n                }\n            ],\n            \"labels_span\": []\n        }\n    ],\n    \"data\": \"@united obviously\",\n    \"metadata\": [],\n    \"tokens\": [],\n    \"uuid\": \"ee408271-df5d-435c-af25-72df58a21bfe\"\n}\n</code></pre>"},{"location":"references/subset/#labeler_client.subset.Subset.suggest_similar","title":"<code>suggest_similar(record_meta_name, limit=3)</code>","text":"<p>For each data record in the subset, suggest more similar data records     by retriving the most similar data records from the pool, based on     metadata(e.g., embedding) distance.</p> <p>Parameters:</p> Name Type Description Default <code>record_meta_name</code> <code>str</code> <p>The meta-name eg. \"bert-embedding\" for which the similarity is calculated upon.</p> required <code>limit</code> <code>int</code> <p>The number of matching/similar records desired to be returned. Default is 3</p> <code>3</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If response code is not successful</p> <p>Returns:</p> Name Type Description <code>subset</code> <code>Subset</code> <p>A subset of similar data entries</p>"},{"location":"references/subset/#labeler_client.subset.Subset.assign","title":"<code>assign(annotator)</code>","text":"<p>Assign the current subset as payload to an annotator.</p> <p>Parameters:</p> Name Type Description Default <code>annotator</code> <code>str</code> <p>Annotator ID.</p> required"}]}